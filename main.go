package main

import (
	"encoding/json"
	"fmt"
	_ "game-node-search/docs" // docs is generated by Swag CLI, you have to import it.
	"game-node-search/search/games"
	"game-node-search/search/users"
	"game-node-search/util"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	"github.com/swaggo/http-swagger/v2"
	"io"
	"log/slog"
	"net/http"
)

// @title GameNode Search API
// @version 1.0
// @description The GameNode Search API documentation.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url gamenode.com.br/help
// @contact.email support@gamenode.com.br

// @license.name GNU General Public License
// @license.url http://www.gnu.org/licenses/

func main() {
	r := chi.NewRouter()
	r.Use(middleware.RequestID)
	r.Use(middleware.RealIP)
	r.Use(middleware.Logger)
	r.Use(middleware.Recoverer)
	// Basic CORS
	// Required to use the browser's native fetch API (XMLHttpRequest)
	// for more ideas, see: https://developer.github.com/v3/#cross-origin-resource-sharing
	r.Use(cors.Handler(cors.Options{
		// AllowedOrigins:   []string{"https://foo.com"}, // Use this to allow specific origin hosts
		AllowedOrigins: []string{"https://*", "http://*"},
		// AllowOriginFunc:  func(r *http.Request, origin string) bool { return true },
		AllowedMethods:   []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))
	r.Mount("/swagger/{param}", httpSwagger.Handler())
	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
		_, err := w.Write([]byte("Hello World!"))
		if err != nil {
			return
		}
	})
	r.Post("/search/games", func(w http.ResponseWriter, r *http.Request) {
		defer r.Body.Close()
		reqDtoBytes, _ := io.ReadAll(r.Body)
		reqDto, err := games.ValidateGameSearchRequest(reqDtoBytes)
		if err != nil {
			slog.Error("Error while responding to request: ", "err", err)
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte(err.Error()))
			return
		}
		response, err := games.GameSearchHandler(reqDto)
		w.Header().Set("Content-Type", "application/json")
		if err != nil {
			slog.Error("Error while responding to request: ", "err", err)
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte(err.Error()))
			return
		}
		responseBytes, _ := json.Marshal(response)
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write(responseBytes)
		return
	})
	r.Post("/search/users", func(w http.ResponseWriter, r *http.Request) {
		defer r.Body.Close()
		reqDtoBytes, _ := io.ReadAll(r.Body)
		reqDto, err := users.ValidateUserSearchRequest(reqDtoBytes)
		if err != nil {
			slog.Error("Error while responding to request: ", "err", err)
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte(err.Error()))
			return
		}
		response, err := users.UserSearchHandler(reqDto)
		w.Header().Set("Content-Type", "application/json")
		if err != nil {
			slog.Error("Error while responding to request: ", "err", err)
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte(err.Error()))
			return
		}
		responseBytes, _ := json.Marshal(response)
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write(responseBytes)
		return
	})
	port := util.GetEnv("PORT", ":9000")
	fmt.Print("Server listening on port: ", port)
	_ = http.ListenAndServe(port, r)

}
